<?php
$title = $this->translate("Site Planner");
$this->headTitle($title);

$this->headScript()->appendFile('/libs/fabric.js/fabric.js');
$this->headScript()->appendFile('/libs/map.js');
?>
<h1><?php echo $this->escapeHtml($title); ?></h1>
<style>
    #sitePlanner {
        display: flex;
    }
    #sitePlanner .canvas {
        flex-grow: 1;
    }
    #sitePlanner .planner-controls {
        flex: 0 0 200px;
        width: 200px;
        padding: 5px;
    }
    /*#sitePlanner .planner-controls .image-export {*/
        /*display: none;*/
    /*}*/
    #sitePlanner .planner-controls ul {
        list-style: none;
    }
    #sitePlanner .plan-select {
        float: left;
        width: 120px;
        margin-left: 0px;
    }
    #sitePlanner button.load-plan {
        float: right;
        margin-top: 0px;
    }
    #sitePlanner hr {
        clear:both;
        margin: 10px 0 10px 0;
        padding: 1px 0 1px 0;
        background-color: black;
    }
    #sitePlanner .planner-controls label[for] {
        float: left;
        margin-top: 0px;
    }
    #lon,
    #lat,
    #zoom,
    #scale-select,
    #diameter,
    #maptype-select {
        width: 95px;
        float: right;
    }
    #sitePlanner .setMap {
        margin: 10px 0 10px 0;
        float: right;
        height: 33px;
    }
    .details-panel {
        width: 200px;
    }
    .details-panel-box boxcontent{
        margin: 0;
        padding: 0;
        padding-left: 5px;
    }
    .details-panel-box boxcontent * {
        width: 150px;
    }
    .details-panel-box boxcontent span {
        width: 90px;
    }
    #image-export-ui .preview img {
        max-width: 200px;
        max-height: 350px;
    }
    label>span:first-child
    {
        top: auto;
    }
    div[data-usage="subDetail"]
    {
        display: none;
    }

</style>
<h3>control:</h3>
<ul>
    <li>move view port with left mouse + drag</li>
    <li>select object with left mouse</li>
    <li>remove selected objects with "entf" key</li>
    <li>select multipy objects with "strg" key + left mouse + drag</li>
</ul>
<box id="sitePlanner">
    <div class="planner-controls">
        <div id="image-export-ui" class="image-export hidden">
            <button class="abort">Zurück</button>
            <button class="crop">Crop</button>
            <br><br>
            <label>
                <span>Zoom</span>
                <input class="crop" data-key="zoom" type="number" min="0.3" max="3" step="0.1" style="height: 16px; width: 95px;">
            </label>
            <label>
                <span>Breite</span>
                <input class="crop" data-key="width" type="number" style="height: 16px; width: 95px;">
            </label>
            <label>
                <span>Höhe</span>
                <input class="crop" data-key="height" type="number" style="height: 16px; width: 95px;">
            </label>
            <div class="preview"></div>
            <div class="save-box" style="display: none">
                <label>
                    <span>Bild Name</span>
                    <input id="image-name" type="text" placeholder="NAME" style="height: 16px; width: 95px;">
                </label>
                <button class="save-image">Bild Speichern</button>
            </div>
        </div>
        <div id="default-ui" class="default">
            <label>
                <span>Pläne</span>
                <select class="plan-select"></select>
            </label>
            <button class="load-plan"> Load </button>
            <div style="clear:both"></div>
            <label>
                <span>Name</span>
                <input id="plan-name" type="text" placeholder="NAME" style="height: 16px; width: 95px;">
            </label>
            <button class="save-plan">Save</button>
            <button class="new-plan" style="float:right">New</button>
            <hr>
            <label for="lon">Longitude:</label>
            <input id="lon" type="number">
            <br>
            <label for="lat">Latitude:</label>
            <input id="lat" type="number">
            <br>
            <label for="zoom">Zoom:</label>
            <input id="zoom" type="number" min="1" max="7" step="1">
            <br>
            <label for="scale-select">Quality:</label>
            <select id="scale-select">
                <option value="1">1</option>
                <option value="2">2</option>
            </select>
            <br>
            <label for="maptype-select">map type:</label>
            <select id="maptype-select">
                <option value="terrain">Terrain</option>
                <option value="satellite">Satellite</option>
                <option value="roadmap">Roadmap</option>
                <option value="hybrid">Hybrid</option>
            </select>
            <label for="diameter">Map size:</label>
            <input id="diameter" type="number" min="1" max="5" step="1">
            <br>
            <div style="clear:both"></div>
            <button class="setMap">Set Map</button>

            <hr>
            <button class="addText">Text Feld</button>
            <button class="createImage">Create Image</button>
            <hr>
            <ul class="itemList">
            <?php
            foreach($items as $item): ?>
                <li data-id="<?php echo $item['id']; ?>">
                    <span class="type" data-type="<?php echo $item['itemType'] ?>"> <?php
                        $color = ($item['itemType'] == 0) ? 'darkgreen' : '#430c0c';
                        echo '<span style="color:'. $color .'">' .$item['name']. '</span>'
                        ?> </span>
                    <span class="user"><?php echo $item['userName'] ?></span>
                </li>
            <?php endforeach; ?>
        </ul>
        </div>
    </div>
    <div class="canvas">
        <canvas class="site-planner-canvas"><?php echo json_encode($items); ?></canvas>
    </div>
    <div class="details-panel">
        <box class="details-panel-box">
            <div data-type="global" >
                <boxtitle>
                    <span>Global</span>
                </boxtitle>
                <boxcontent>
                    <button data-func="sendBackwards">send Backwards</button>
                    <button data-func="sendToBack">send To Back</button>
                    <button data-func="bringForward">bring Forward</button>
                    <button data-func="bringToFront">bring To Front</button>
                </boxcontent>
                <br>
            </div>
            <div data-type="textbox" data-usage="subDetail">
                <boxtitle>
                    <span>Text Box</span>
                </boxtitle>
                <boxcontent>
                    <label>
                        <span>Font size:<br></span>
                        <input data-key="fontSize" type="number" min="5" max="40" step="1">
                    </label>
                    <br>
                    <br>
                    <label>
                        <span>Text color:</span>
                        <input type="color" data-key="fill">
                    </label>
                    <br/>
                    <br/>
                    <label>
                        <span>background color:</span>
                        <input type="color" data-key="backgroundColor">
                    </label>
                    <br/>
                    <br/>
                </boxcontent>
                <br>
            </div>
            <div data-type="Equipitem" data-usage="subDetail">
                <boxtitle>
                    <span>Aussrüstungs teil</span>
                </boxtitle>
                <boxcontent>
                    <label alt="labelRender">
                        <span>Show Labels</span>
<!--                        <input data-key="labelRender" type="hidden" name="label-checkbox" value="0">-->
                        <input data-key="labelRender" type="checkbox" name="label-checkbox" class="input-error" value="1">
                    </label>
                    <br>
                    <br>
                    <label alt="labelPosition">
                        <span>position:</span>
                        <select data-key="labelPosition">
                            <option value="0">top</option>
                            <option value="1">right</option>
                            <option value="2">bottom</option>
                            <option value="3">left</option>
                        </select>
                    </label>
                    <br>
                    <br>
                    <label alt="labelOffsetX">
                        <span>Offset X:<br></span>
                        <input data-key="labelOffsetX" type="number" min="5" max="40" step="1">
                    </label>
                    <br>
                    <br>
                    <label alt="labelOffsetY">
                        <span>Offset Y:<br></span>
                        <input data-key="labelOffsetY" type="number" min="5" max="40" step="1">
                    </label>
                    <br>
                    <br>
                    <label alt="labelFontType">
                        <span>Schriftart:</span>
                        <select data-key="labelFontType">
                            <option value="Arial">Arial</option>
                            <option value="Comic Sans MS">Comic Sans MS</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Webdings">Webdings</option>
                        </select>
                    </label>
                    <br>
                    <br>
                    <label alt="labelFontSize">
                        <span>Font size:<br></span>
                        <input data-key="labelFontSize" type="number" min="5" max="40" step="1">
                    </label>
                    <br>
                    <br>
                    <label alt="labelTextColor">
                        <span>Text color:</span>
                        <input type="color" data-key="labelTextColor">
                    </label>
                    <br>
                    <br>
                    <label alt="labelBgColor">
                        <span>background color:</span>
                        <input type="color" data-key="labelBgColor">
                    </label>
                </boxcontent>
                <br>
            </div>
            <div data-type="image" data-usage="subDetail">
                <boxtitle>
                    <span>Image</span>
                </boxtitle>
                <boxcontent>
                    <button data-func="sendBackwards">send Backwards</button>
                    <button data-func="sendToBack">send To Back</button>
                    <button data-func="bringForward">bring Forward</button>
                    <button data-func="bringToFront">bring To Front</button>
                </boxcontent>
                <br>
            </div>
        </box>
    </div>
</box>
<script>
    (function () {
        var supportQuality = fabric.StaticCanvas.supports('toBlobWithQuality');
        fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

            /**
             * Exports canvas element to a blob image. Note that when multiplier is used, cropping is scaled appropriately
             * @param {Object} [options] Options object
             * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
             * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
             * @param {Number} [options.multiplier=1] Multiplier to scale by
             * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
             * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
             * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
             * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
             * @param {Function} [callback] function callback
             */
            toBlob: function (options, callback) {
                options || (options = { });

                var format = options.format || 'png',
                    quality = options.quality || 1,
                    multiplier = options.multiplier || 1,
                    cropping = {
                        left: options.left || 0,
                        top: options.top || 0,
                        width: options.width || 0,
                        height: options.height || 0,
                    };
                this.__toBlobWithMultiplier(format, quality, cropping, multiplier, callback);
            },

            /**
             * @private
             */
            __toBlobWithMultiplier: function(format, quality, cropping, multiplier, callback) {

                var origWidth = this.getWidth(),
                    origHeight = this.getHeight(),
                    scaledWidth = (cropping.width || this.getWidth()) * multiplier,
                    scaledHeight = (cropping.height || this.getHeight()) * multiplier,
                    zoom = this.getZoom(),
                    newZoom = zoom * multiplier,
                    vp = this.viewportTransform,
                    translateX = (vp[4] - cropping.left) * multiplier,
                    translateY = (vp[5] - cropping.top) * multiplier,
                    newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
                    originalInteractive = this.interactive;

                this.viewportTransform = newVp;
                // setting interactive to false avoid exporting controls
                this.interactive && (this.interactive = false);
                if (origWidth !== scaledWidth || origHeight !== scaledHeight) {
                    // this.setDimensions is going to renderAll also;
                    this.setDimensions({ width: scaledWidth, height: scaledHeight });
                }
                else {
                    this.renderAll();
                }
                var data = this.__toBlob(format, quality, cropping, callback);
                originalInteractive && (this.interactive = originalInteractive);
                this.viewportTransform = vp;
                //setDimensions with no option object is taking care of:
                //this.width, this.height, this.renderAll()
                this.setDimensions({ width: origWidth, height: origHeight });
            },

            /**
             * @private
             */
            __toBlob: function(format, quality, cropping, callback) {

                var canvasEl = this.contextContainer.canvas;
                // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
                if (format === 'jpg') {
                    format = 'jpeg';
                }

                var data = supportQuality
                    ? canvasEl.toBlob(callback, 'image/' + format, quality)
                    : canvasEl.toBlob(callback, 'image/' + format);
            },

            /**
             * Exports canvas element to a Blob image (allowing to change image size via multiplier).
             * @deprecated since 1.0.13
             * @param {String} format (png|jpeg)
             * @param {Number} multiplier
             * @param {Number} quality (0..1)
             * @return {String}
             */
            toBlobWithMultiplier: function (format, multiplier, quality, callback) {
                return this.toBlob({
                    format: format,
                    multiplier: multiplier,
                    quality: quality
                }, callback);
            },
        });
    })();
    (function($) {
        "use strict";
        var RIGHT_CLICK = 3,
            MIDDLE_CLICK = 2,
            LEFT_CLICK = 1,
            ENUM_ItemType_Tent = 0,
            ENUM_ItemType_Equip = 1,
            ENUM_ItemShape_Round = 0,
            ENUM_ItemShape_Rectangel = 1,
            ENUM_ItemShape_Oval = 2,
            ENUM_TentShape_Round = 0,
            ENUM_TentShape_Rectangle = 1,
            ENUM_TentShape_Rectangle_Two_Mast = 2,
            ENUM_TentShape_Round_Rectangle = 3;

        function checkClick(e, value) {
            return 'which' in e ? e.which === value : e.button === value - 1;
        }
        fabric.MyCanvas = fabric.util.createClass(fabric.Canvas, fabric.StaticCanvas, /** @lends fabric.Canvas.prototype **/ {
            _isViewPortDragging: false,
            maxZoomLevel: 3,
            minZoomLevel: 0.3,

            zoomToPoint: function (point, value) {
                var result = fabric.StaticCanvas.prototype.zoomToPoint.call(this, point, this.__capZoomLevel(value));
                this.trigger('zoom', this.viewportTransform[0]);
                return result;
            },
            centerObject: function(obj) {
                var center = this.getCenter();
                center = new fabric.Point(center.left, center.top);
                var after = fabric.util.transformPoint(center, fabric.util.invertTransform(this.viewportTransform.slice(0)));
                this._centerObject(obj, after);
                obj.setCoords();
            },
            setViewPort: function(deltax = 0, deltay = 0) {
                this.absolutePan({
                    x: deltax,
                    y: deltay
                });
            },
            moveViewPort: function(deltax = 0, deltay = 0) {
                this.relativePan({
                    x: deltax,
                    y: deltay
                });
            },
            __onMouseDown: function (e) {
                var target = this.findTarget(e);

                // if right click just fire events
                if (checkClick(e, RIGHT_CLICK)) {
                    if (this.fireRightClick) {
                        this._handleEvent(e, 'down', target ? target : null, RIGHT_CLICK);
                    }
                    return;
                }

                if (checkClick(e, MIDDLE_CLICK)) {
                    if (this.fireMiddleClick) {
                        this._handleEvent(e, 'down', target ? target : null, MIDDLE_CLICK);
                    }
                    return;
                }

                if (this.isDrawingMode) {
                    this._onMouseDownInDrawingMode(e);
                    return;
                }

                // ignore if some object is being transformed at this moment
                if (this._currentTransform) {
                    return;
                }

                // save pointer for check in __onMouseUp event
                var pointer = this.getPointer(e, true);
                this._previousPointer = pointer;

                var ctrlKey = e.ctrlKey,
                    shouldRender = this._shouldRender(target, pointer),
                    shouldGroup = this._shouldGroup(e, target);

                if (this._shouldClearSelection(e, target)) {
                    this.deactivateAllWithDispatch(e);
                }
                else if (shouldGroup) {
                    this._handleGrouping(e, target);
                    target = this.getActiveGroup();
                }

                if (ctrlKey && this.selection && (!target || (!target.selectable && !target.isEditing))) {
                    this._groupSelector = {
                        ex: pointer.x,
                        ey: pointer.y,
                        top: 0,
                        left: 0
                    };
                }
                if (target) {
                    if (target.selectable && (target.__corner || !shouldGroup)) {
                        this._beforeTransform(e, target);
                        this._setupCurrentTransform(e, target);
                    }
                    var activeObject = this.getActiveObject();
                    if (target !== this.getActiveGroup() && target !== activeObject) {
                        this.deactivateAll();
                        if (target.selectable) {
                            activeObject && activeObject.fire('deselected', { e: e });
                            this.setActiveObject(target, e);
                        } else if (!ctrlKey) {
                            this._isViewPortDragging = true;
                        }
                    }
                }
                else if (!ctrlKey) {
                    this._isViewPortDragging = true;
                }
                this._handleEvent(e, 'down', target ? target : null);
                // we must renderAll so that we update the visuals
                shouldRender && this.renderAll();
            },
            /**
             * Method that defines the actions when mouse is hovering the canvas.
             * The currentTransform parameter will definde whether the user is rotating/scaling/translating
             * an image or neither of them (only hovering). A group selection is also possible and would cancel
             * all any other type of action.
             * In case of an image transformation only the top canvas will be rendered.
             * @private
             * @param {Event} e Event object fired on mousemove
             */
            __onMouseMove: function (e) {
                var target, pointer;

                if (this.isDrawingMode) {
                    this._onMouseMoveInDrawingMode(e);
                    return;
                }
                if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
                    return;
                }

                if (this._isViewPortDragging) {
                    this.moveViewPort(e.movementX, e.movementY);
//                    this.renderAll();
                }
                var groupSelector = this._groupSelector;
                // We initially clicked in an empty area, so we draw a box for multiple selection
                if (groupSelector) {
                    pointer = this.getPointer(e, true);

                    groupSelector.left = pointer.x - groupSelector.ex;
                    groupSelector.top = pointer.y - groupSelector.ey;

                    this.renderTop();
                } else if (!this._currentTransform) {
                    target = this.findTarget(e);
                    this._setCursorFromEvent(e, target);
                }
                else {
                    this._transformObject(e);
                }
                this._handleEvent(e, 'move', target ? target : null);
            },
            /**
             * Method that defines the actions when mouse is released on canvas.
             * The method resets the currentTransform parameters, store the image corner
             * position in the image object and render the canvas on top.
             * @private
             * @param {Event} e Event object fired on mouseup
             */
            __onMouseUp: function (e) {
                var target;
                // if right/middle click just fire events and return
                // target undefined will make the _handleEvent search the target
                if (checkClick(e, RIGHT_CLICK)) {
                    if (this.fireRightClick) {
                        this._handleEvent(e, 'up', target, RIGHT_CLICK);
                    }
                    return;
                }

                if (checkClick(e, MIDDLE_CLICK)) {
                    if (this.fireMiddleClick) {
                        this._handleEvent(e, 'up', target, MIDDLE_CLICK);
                    }
                    return;
                }

                this._isViewPortDragging = false;
                if (this.isDrawingMode && this._isCurrentlyDrawing) {
                    this._onMouseUpInDrawingMode(e);
                    return;
                }

                var searchTarget = true, transform = this._currentTransform,
                    groupSelector = this._groupSelector,
                    isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));

                if (transform) {
                    this._finalizeCurrentTransform();
                    searchTarget = !transform.actionPerformed;
                }

                target = searchTarget ? this.findTarget(e, true) : transform.target;

                var shouldRender = this._shouldRender(target, this.getPointer(e));

                if (target || !isClick) {
                    this._maybeGroupObjects(e);
                }
                else {
                    // those are done by default on mouse up
                    // by _maybeGroupObjects, we are skipping it in case of no target find
                    this._groupSelector = null;
                    this._currentTransform = null;
                }

                if (target) {
                    target.isMoving = false;
                }
                this._setCursorFromEvent(e, target);
                this._handleEvent(e, 'up', target ? target : null, LEFT_CLICK, isClick);
                target && (target.__corner = 0);
                shouldRender && this.renderAll();
            },
            /**
             * Method that defines actions when an Event Mouse Wheel
             * @param {Event} e Event object fired on mouseup
             */
            __onMouseWheel: function(e) {
                //@todo implement zooming
                //check key
//                if (e.ctrlKey) {
                var zoom = this.viewportTransform[0];
                zoom += (e.wheelDelta < 0)? -0.1: +0.1;
                zoom =  this.__capZoomLevel(zoom);
                this.zoomToPoint(new fabric.Point(e.offsetX, e.offsetY), zoom);
                e.preventDefault();
            },
            __capZoomLevel(value) {
                return Math.max(this.minZoomLevel, Math.min(this.maxZoomLevel, value));
            },
        });

        fabric.CropBox = fabric.util.createClass(fabric.Rect, {
            type: 'CropBox',
            objectCaching: false,

            /**
             * Constructor
             * @param {Object} [options] Options object
             * @return {fabric.Circle} thisArg
             */
            initialize: function(options) {
                this.callSuper('initialize', options);
                this.setControlsVisibility({
                    mtr: false,
                });

                this.on('deselected', function(e) {
                    this.moveTo(100);
                }.bind(this));
                this.on('mouse:down', function(e) {
//                    console.log('########### mouse down');
                }.bind(this));
//                this.on('deselected', function(e) {
//                    this.moveTo(100);
//                }.bind(this));
            },
            _render: function(ctx) {
//                fabric.Rect.prototype._render.call(this, ctx);
                if (!this.canvas) return;
                this.renderOverlay(ctx);
            },
            renderOverlay: function(ctx) {
                var top = 100,
                    bottom = this.canvas.height - 100,
                    left = 200,
                    right = this.canvas.width - 200,
                    wHalf = this.width / 2;

                ctx.save();
                //draw dark outer area
                ctx.fillStyle = "rgba(0,0,0,0.8)";
                for(var i = 0; i < 4; i++) {
                    ctx.rotate( (Math.PI / 2) * i );
                    ctx.fillRect(wHalf, -wHalf - 0.1, 5000, 5000);
                }
                ctx.restore();
            },
        });
        fabric.Equipitem = fabric.util.createClass(fabric.Object, {
            type: 'Equipitem',
            labelRender: true,
            labelPosition: 0,//0=top, 1=right, 2=bottom, 3=left
            labelFontSize: 20,
            labelOffsetX: 0,
            labelOffsetY: 0,
            labelFontType: 'Arial',
            labelBgColor: '#fafafa',
            labelTextColor: '#000000',
            radius: 40,
            startAngle: 0,
            endAngle: Math.PI * 2,
            objectCaching: false,

            /**
             * Constructor
             * @param {Object} [options] Options object
             * @return {fabric.Circle} thisArg
             */
            initialize: function(options) {
                this.callSuper('initialize', options);

                this.setControlsVisibility({
                    bl: false,
                    br: false,
                    mb: false,
                    ml: false,
                    mr: false,
                    mt: false,
                    tl: false,
                    tr: false,
                    mtr: true,
                });
                this.on('deselected', function(e) {
                    this.moveTo(100);
                }.bind(this));
                this.on('mouse:down', function(e) {
//                    console.log('########### mouse down');
                }.bind(this));
//                this.on('deselected', function(e) {
//                    this.moveTo(100);
//                }.bind(this));
            },
            setItem: function (item) {
                this.width = parseInt(item.width) / 5;
                this.height = parseInt(item.depth) / 5;
                this.item = item;
                this.selectable = true;
                var imageIndex = preloadUrls.indexOf(item.image);
                if (imageIndex >= 0 && item.itemType !== 0) {
                    this.itemImg = preloadedImages[imageIndex];
                }
            },
            _render: function(ctx) {
                var w = this.width,
                    h = this.height,
                    i = 0,
                    mastCenterX = 0,
                    mastCenterY = 0,
                    landscape = ( w >= h ),
                    designColor = '#000000';
                    if (this.item.color1 == '#000000' || this.item.color2 == '#000000') {
                        designColor = '#708090 ';
                    }

                switch (parseInt(this.item.itemType))
                {
                    case ENUM_ItemType_Tent:
                        switch (parseInt(this.item.shape)) {
                            case ENUM_TentShape_Round:
                                var count = 8,
                                    startAngle = 0,
                                    angleSize = (2 * Math.PI) / count;

                                // entrance, adjusted 25 to 15 for shape reasons
                                ctx.beginPath();
                                ctx.moveTo(-(w/6), - ((h / 2) - 10));
                                ctx.lineTo( (w/6), - ((h / 2) - 10));
                                ctx.lineTo( (w/6), - ((h / 2) + 15));
                                ctx.lineTo(-(w/6), - ((h / 2) + 15));
                                ctx.lineTo(-(w/6), - ((h / 2) - 10));
                                ctx.fillStyle = this.item.color1;
                                ctx.strokeStyle = designColor;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                ctx.fill();

                                for(i = 0; i < count; i++) {
                                    if (this.item.biColor == 0 || i % 2 == 0) {
                                        ctx.fillStyle = this.item.color1;
                                    } else {
                                        ctx.fillStyle = this.item.color2;
                                    }

                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.arc(0, 0, this.width/2, startAngle, startAngle + angleSize);
                                    ctx.closePath();
                                    ctx.fill();
                                    startAngle += angleSize;
                                }
                                // mast
                                ctx.beginPath();
                                ctx.moveTo(0,0);
                                ctx.arc (mastCenterX,mastCenterY,2,0, 2* Math.PI, false);
                                ctx.fillStyle = designColor;
                                ctx.fill();

                                break;
                            case ENUM_TentShape_Rectangle: // 1 = rectangle, one mast tent
                                // entrance
                                ctx.beginPath();
                                ctx.moveTo(-(w/6), - ((h / 2) - 10));
                                ctx.lineTo( (w/6), - ((h / 2) - 10));
                                ctx.lineTo( (w/6), - ((h / 2) + 25));
                                ctx.lineTo(-(w/6), - ((h / 2) + 25));
                                ctx.lineTo(-(w/6), - ((h / 2) - 10));
                                ctx.fillStyle = this.item.color1;
                                ctx.strokeStyle = designColor;
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                ctx.fill();

                                ctx.fillStyle = this.item.color1;
                                ctx.fillRect(-(w/2), -(h/2), w, h);

                                for (i = 0; i < 4; i++) {
                                    if (i % 2 == 0) {
                                        w = this.width;
                                        h = this.height;
                                    } else {
                                        w = this.height;
                                        h = this.width;
                                    }
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.lineTo(0, -(h/2) );
                                    ctx.lineTo(w/2, -(h/2) );
                                    ctx.lineTo(0, 0);
                                    ctx.fillStyle = this.item.color2;
                                    ctx.fill();
                                    ctx.rotate(Math.PI / 2);
                                }

                                w = this.width;
                                h = this.height;
                                // mast
                                ctx.beginPath();
                                ctx.moveTo(0,0);
                                ctx.arc (mastCenterX,mastCenterY,2,0, 2* Math.PI, false);
                                ctx.fillStyle = designColor;
                                ctx.fill();

                                // folding lines
                                ctx.beginPath();
                                ctx.moveTo( -(w/2), -(h/2));
                                ctx.lineTo( 0, 0 );
                                ctx.lineTo( -(w/2), (h/2));
                                ctx.moveTo(  (w/2), (h/2));
                                ctx.lineTo( 0, 0);
                                ctx.lineTo(  (w/2), -(h/2) );
                                ctx.strokeStyle = designColor;
                                ctx.stroke();
                                break;
                            case ENUM_TentShape_Rectangle_Two_Mast: // 2 = rectangle, two mast tent
                                if (!landscape) {
                                    h = this.width;
                                    w = this.height;
                                }
                                var sC = 1;
                                mastCenterX = w/6;
                                // entrance
                                ctx.beginPath();
                                ctx.moveTo(-(w/6), - ((h / 2) - 10));
                                ctx.lineTo( (w/6), - ((h / 2) - 10));
                                ctx.lineTo( (w/6), - ((h / 2) + 25));
                                ctx.lineTo(-(w/6), - ((h / 2) + 25));
                                ctx.lineTo(-(w/6), - ((h / 2) - 10));
                                ctx.fillStyle = this.item.color1;
                                ctx.strokeStyle = designColor;
                                ctx.stroke();
                                ctx.fill();

                                // tent
                                ctx.beginPath();
                                ctx.fillStyle = this.item.color1;
                                ctx.fillRect(-(w/2), -(h/2), w, h);

                                if (this.item.biColor == 1) {
                                    for (i = 0; i < 2; i++) {
                                        sC = -sC;
                                        ctx.beginPath();
                                        ctx.moveTo(sC*mastCenterX, 0);
                                        ctx.lineTo(sC*(w / 2), sC*(h / 2));
                                        ctx.lineTo(sC*(w / 2), sC*(h / 6));
                                        ctx.lineTo(sC*mastCenterX, 0);
                                        ctx.lineTo(sC*(w / 2), -sC*(h / 2));
                                        ctx.lineTo(sC*(w / 2), -sC*(h / 6));
                                        ctx.lineTo(sC*mastCenterX, 0);
                                        ctx.moveTo(sC*mastCenterX, sC*(h/2));
                                        ctx.lineTo(sC*(w/18), sC*(h/2));
                                        ctx.lineTo(sC*(w/18), -sC*(h/2));
                                        ctx.lineTo(sC*mastCenterX, -sC*(h/2));
                                        ctx.lineTo(sC*mastCenterX, sC*(h/2));
                                        ctx.fillStyle = this.item.color2;
                                        ctx.fill();
                                    }
                                }

                                // mast 1
                                ctx.beginPath();
                                ctx.moveTo(mastCenterX, 0);
                                ctx.arc (mastCenterX, 0, 2, 0, 2* Math.PI, false);
                                // mast 2
                                ctx.moveTo(-mastCenterX, 0);
                                ctx.arc (-mastCenterX, 0, 2, 0, 2* Math.PI, false);
                                ctx.fillStyle = designColor;
                                ctx.fill();

                                // folding lines
                                ctx.beginPath();
                                ctx.moveTo( -(w/2), -(h/2));
                                ctx.lineTo( -mastCenterX, -mastCenterY);
                                ctx.lineTo(  mastCenterX, mastCenterY);
                                ctx.lineTo( w/2, -(h/2));
                                ctx.moveTo( w/2, h/2);
                                ctx.lineTo(  mastCenterX, mastCenterY);
                                ctx.lineTo(  -mastCenterX, -mastCenterY);
                                ctx.lineTo( -(w/2), h/2);
                                ctx.strokeStyle = designColor;
                                ctx.stroke();
                                break;
                            case ENUM_TentShape_Round_Rectangle: // 3 => two mast tent with round corners
                                if (!landscape) {
                                    h = this.item.width;
                                    w = this.item.height;
                                }
                                var rectWidth = w - h,
                                    startAngel = Math.PI/2;
                                mastCenterX = (rectWidth/2);

                                // tent
                                ctx.beginPath();
                                ctx.moveTo(-mastCenterX, 0);
                                ctx.arc(-mastCenterX, 0, h/2, startAngel, startAngel + Math.PI);
                                ctx.moveTo( mastCenterX, 0);
                                ctx.arc ( mastCenterX, 0, h/2, -startAngel, -startAngel + Math.PI);
                                ctx.moveTo ( -mastCenterX, -(h/2));
                                ctx.lineTo (  mastCenterX, -(h/2));
                                ctx.lineTo (  mastCenterX,   h/2);
                                ctx.lineTo ( -mastCenterX,   h/2);
                                ctx.lineTo ( -mastCenterX, -(h/2));
                                ctx.fillStyle = this.item.color1;
                                ctx.fill();

                                if (this.item.biColor == 1) {
                                    for (var side = 0; side < 2; side++) {
                                        var xx,
                                            slices = 3,
                                            angelDiff = Math.PI / slices;
                                        // making slices odd
                                        if (slices % 2 == 0) {
                                            slices++;
                                        }
                                        if (side % 2 == 0) {
                                            startAngel = Math.PI/2;
                                            xx = -mastCenterX;
                                        } else {
                                            startAngel = -(Math.PI/2);
                                            xx = mastCenterX;
                                        }
                                        for (i = 0; i < slices; i++) {
                                            if (!(i % 2 == 0)) continue;
                                            ctx.beginPath();
                                            ctx.moveTo(xx, 0);
                                            ctx.arc(xx, 0, h/2, startAngel, startAngel + angelDiff);
                                            ctx.fillStyle = this.item.color2;
                                            ctx.fill();
                                            startAngel = startAngel + (2 * angelDiff);
                                        }
                                    }
                                }

                                // mast 1
                                ctx.beginPath();
                                ctx.moveTo(mastCenterX, mastCenterY);
                                ctx.arc (mastCenterX, mastCenterY, 2, 0, 2* Math.PI, false);
                                ctx.fillStyle = designColor;
                                ctx.fill();
                                // mast 2
                                ctx.beginPath();
                                ctx.moveTo(-mastCenterX, -mastCenterY);
                                ctx.arc (-mastCenterX, -mastCenterY, 2, 0, 2* Math.PI, false);
                                ctx.fillStyle = designColor;
                                ctx.fill();

                                // folding lines
                                ctx.beginPath();
                                ctx.moveTo( -mastCenterX, -mastCenterY);
                                ctx.lineTo(  mastCenterX, mastCenterY);
                                ctx.strokeStyle = designColor;
                                ctx.stroke();

                                // entrance
                                ctx.beginPath();
                                ctx.moveTo(-(mastCenterX-3), 0);
                                ctx.lineTo( (mastCenterX-3), 0);
                                ctx.lineTo( (mastCenterX-3), - ((h / 2) + 15));
                                ctx.lineTo(-(mastCenterX-3), - ((h / 2) + 15));
                                ctx.lineTo(-(mastCenterX-3), 0);
                                ctx.fillStyle = this.item.color2;
                                ctx.strokeStyle = designColor;
                                ctx.stroke();
                                ctx.fill();
                                break;
                            default:
                                if (this.itemImg) {
                                    ctx.drawImage(this.itemImg, -this.width/2, -this.height/2, this.width, this.height);
                                }
                                break;
                            }
                        break;
                    case ENUM_ItemType_Equip:
                    default:
                        if (this.item.image !== null) {
                            ctx.drawImage(this.itemImg, -this.width/2, -this.height/2, this.width, this.height);
                        } else {
                            switch (parseInt(this.item.shape)) {
                                case ENUM_ItemShape_Round:
                                    ctx.beginPath();
                                    ctx.moveTo(0,0);
                                    ctx.arc (0,0,w/2,0, 2* Math.PI, false);
                                    break;
                                case ENUM_ItemShape_Rectangel:
                                    ctx.beginPath();
                                    ctx.moveTo(-w/2, -h/2);
                                    ctx.lineTo( w/2, -h/2);
                                    ctx.lineTo( w/2,  h/2);
                                    ctx.lineTo(-w/2,  h/2);
                                    ctx.lineTo(-w/2, -h/2);
                                    break;
                                case ENUM_ItemShape_Oval:
                                    ctx.beginPath();
                                    ctx.ellipse(0, 0, w/2, h/2, 0, 0, 2*Math.PI, false);
                            }
                            ctx.fillStyle = this.item.color1;
                            ctx.fill();
                        }
                }


                if (this.labelRender) {
                    var offX = 0,
                        offY = 0,
                        paddingX = 10,
                        paddingY = 6,
                        w = paddingX * 2,
                        h = paddingY * 2 + parseInt(this.labelFontSize),
                        hWidth = this.width / 2,
                        hHeight = this.height / 2,
                        distance = 20,
                        cs = 5;//corner size

                    ctx.save();
                    ctx.font = this.labelFontSize + "px " + this.labelFontType;
                    var textWidth = ctx.measureText(this.item.userName).width;
                    w += textWidth;

                    //calculate label offsets
                    if (this.labelPosition % 2) {
                        offX = (this.labelPosition == 1)? offX + hWidth + distance + textWidth/2: offX - hWidth - distance - textWidth / 2;
                    } else {
                        offY = (this.labelPosition == 2)? offY + hHeight + distance: offY - hHeight - distance;
                    }
                    offX += parseInt(this.labelOffsetX);
                    offY += parseInt(this.labelOffsetY);
                    //transform
                    ctx.rotate(-this.angle * Math.PI / 180);
                    ctx.translate(-w/2 + offX, -h/2 + offY);
                    ctx.beginPath();
                    ctx.moveTo(cs, 0);
                    ctx.lineTo(w - cs, 0);
                    ctx.quadraticCurveTo(w, 0, w, cs);

                    ctx.lineTo(w, h - cs);
                    ctx.quadraticCurveTo(w, h, w - cs, h);
                    ctx.lineTo(cs, h);
                    ctx.quadraticCurveTo(0, h , 0, h - cs);
                    ctx.lineTo(0, cs);
                    ctx.quadraticCurveTo(0, 0, cs, 0);

                    ctx.lineWidth = 1;
                    ctx.strokesStyle = this.labelTextColor;
                    ctx.fillStyle = this.labelBgColor;
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = this.labelTextColor;
                    ctx.textBaseline = "top";
                    ctx.fillText(this.item.userName, paddingX, paddingY);

                    ctx.restore();
                }
            },
            /**
             * Returns an object representation of an instance
             * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
             * @return {Object} Object representation of an instance
             */
            toObject: function(propertiesToInclude) {
                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
                    toFixed = fabric.util.toFixed,
                    object = {
                        type:                     this.type,
                        item:                     this.item,
                        labelRender:              this.labelRender,
                        labelPosition:            this.labelPosition,
                        labelFontSize:            this.labelFontSize,
                        labelFontType:            this.labelFontType,
                        labelBgColor:             this.labelBgColor,
                        labelOffsetX:             this.labelOffsetX,
                        labelOffsetY:             this.labelOffsetY,
                        labelTextColor:           this.labelTextColor,
                        originX:                  this.originX,
                        originY:                  this.originY,
                        left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
                        top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
                        width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
                        height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
                        fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
                        stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
                        strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
                        strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
                        strokeLineCap:            this.strokeLineCap,
                        strokeLineJoin:           this.strokeLineJoin,
                        strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
                        scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
                        scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
                        angle:                    toFixed(this.getAngle(), NUM_FRACTION_DIGITS),
                        flipX:                    this.flipX,
                        flipY:                    this.flipY,
                        opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
                        shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
                        visible:                  this.visible,
                        clipTo:                   this.clipTo && String(this.clipTo),
                        backgroundColor:          this.backgroundColor,
                        fillRule:                 this.fillRule,
                        globalCompositeOperation: this.globalCompositeOperation,
                        transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,
                        skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
                        skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)
                    };

                fabric.util.populateWithProperties(this, object, propertiesToInclude);

                if (!this.includeDefaultValues) {
                    object = this._removeDefaultValues(object);
                }

                return object;
            },

        });
        fabric.Equipitem.fromObject = function(object, callback) {
            return fabric.Object._fromObject('Equipitem', object, callback);
        };

        //site planner
        var preloadedImages = [];
        var preloadUrls = [];
        var lang = {
            askSure: 'Are you sure?',
            warnSaveData: 'Alle ungespeicherten Daten gehen verloren!',
            successSave: 'Plan wurde gespeichert!',
            imageNameTaken: 'Bild mit diesem namen existiert bereits!',
            ohno: 'Oh No!',
            needPlanName: 'Bitte gieb einen namen ein!',
        };

        //cross origin workaround
        function loadImageAsDataURL(url, callback) {
            var xhr = new XMLHttpRequest();
            xhr.onload = function() {
                var reader = new FileReader();
                reader.onloadend = function() {
                    var img = new Image();
                    img.onload = function () {
                        callback(false, img);
                    };
                    img.onerror = function() {
                        callback(true);
                    };
                    img.src = reader.result;
                }
                reader.readAsDataURL(xhr.response);
            };
            xhr.open('GET', url);
            xhr.responseType = 'blob';
            xhr.send();
        }
        function preloadImagesAsDataURL(urls, callback, progress, error) {
            var pointer = 0,
                images = [];

            function onload(err, image) {
                if (err) {
                    error();
                    return;
                }
                images.push(image);
                pointer++;
                if (pointer < urls.length) {
                    progress(pointer / urls.length);
                    loadImageAsDataURL(urls[pointer], onload);
                } else {
                    callback(images);
                }
            }
            loadImageAsDataURL(urls[pointer], onload);
        }
        //cross origin workaround end
        function loadImage(url, callback) {
            var img = new Image();
            img.onload = callback;
            img.onerror = function() {
                callback(true);
            };
            img.src = url;
            return img;
        }
        function preloadImages(urls, callback, progress){
            var pointer = 0;
            var images = [];

            function onLoad(err) {
                images.push(this);
                pointer++;
                if (pointer < urls.length) {
                    progress(pointer / urls.length);
                    loadImage(urls[pointer], onLoad);
                } else {
                    callback(images);
                }
            }
            loadImage(urls[pointer], onLoad);
        }
        function createGoogleMapStaticImageUrls(options) {
            var result = [];
            var zoom = Math.abs(options.zoom - 7);
            zoom = Math.pow(2, zoom);
            var offlong = zoom * 0.000272;
            var offlat = zoom * 0.000429;
            for (var line = 0; line < options.diameter; line++) {
                for (var pos = 0; pos < options.diameter; pos++) {
                    var center = [
                        Math.floor( (options.longitude - line * offlong) * 1000000  ) / 1000000,
                        Math.floor( (options.latitude + pos * offlat) * 1000000  ) / 1000000,
                    ];
//                    console.log('line: %i  |  pos: %i', line, pos);
//                    console.log(center);
                    var url = $.liveMapLink('AIzaSyDIx0TGGgH1atq7sGFxb3KpnhEnVAFJwxc', {
                        size: '640x640',
                        center: center[0] + ',' + center[1],
                        zoom: 14 + options.zoom,
                        maptype: options.mapType,
                        scale: options.scale,
                    });
                    result.push(url);
                }
            }
            return result;
        }

        class ItemList {
            /**
             * @param {SitePlanner} sitePlanner
             */
            constructor(sitePlanner) {
                /** @type SitePlanner */
                this.sitePlanner = sitePlanner;
                /** @type fabric.Object[] */
                this.items = [];
            }
            hide() {

            }
            show() {

            }
            set(key, value) {
                for(var i = 0; i < this.items.length; i++) {
                    this.items[i].set(key, value);
                }
                this.sitePlanner.canvas.renderAll();
            }
            update() {
                //resize items depending on plan.zoom
                for(var i = 0; i < this.items.length; i++) {
                    var z = Math.abs(this.sitePlanner.plan.zoom - 7);
                    z = Math.pow(2, z);
                    var item = this.items[i];
                    item.scale(1 / z);
                }
                this.sitePlanner.canvas.renderAll();
            }
            create(data, options = {}) {
                options.originX = 'center';
                options.originY = 'center';
                var item = new fabric.Equipitem(options);
                item.setItem(data);
                this.items.push(item);
                this.sitePlanner.canvas.add(item);
                item.bringToFront();
                this.update();
                return item;
            }
            add(fabricObj) {
                this.items.push(fabricObj);
                this.sitePlanner.canvas.add(fabricObj);
                fabricObj.bringToFront();
                this.update();
            }
            remove(obj) {
                var i = this.items.indexOf(obj);
                if (i > -1) {
                    this.items.splice(i, 1);
                    obj.remove();
                    this.sitePlanner.canvas.remove(obj);
                    this.sitePlanner.canvas.renderAll();
                }
            }
            removeSelected() {
                var selected = this.sitePlanner.canvas.getActiveObject();
                var selectedGrp = this.sitePlanner.canvas.getActiveGroup();
                if (selected && selected.type) {
                    this.remove(selected);
                } else if (selectedGrp) {
                    var objs = selectedGrp._objects.slice(0);
                    this.sitePlanner.canvas.discardActiveGroup();
                    for (var i = 0; i < objs.length; i++) {
//                        console.log(selectedGrp);
                        this.remove(objs[i]);
                    }
                    this.sitePlanner.canvas.renderAll();
                }
            }
            clear() {
                this.sitePlanner.canvas.deactivateAll().renderAll();
                for(var i = 0; i < this.items.length; i++) {
                    this.items[i].remove();
                }
                this.items = [];
                this.sitePlanner.canvas.renderAll();
            }
            fromString(str) {
                var self = this;
                var canvas = this.sitePlanner.canvas;
                fabric.util.enlivenObjects(JSON.parse(str), function(objects) {
                    var origRenderOnAddRemove = canvas.renderOnAddRemove;
                    canvas.renderOnAddRemove = false;

                    for(var i = 0; i < objects.length; i++) {
                        canvas.add(objects[i]);
                        self.items.push(objects[i]);
                    }
                    canvas.renderOnAddRemove = origRenderOnAddRemove;
                    self.update();
                    canvas.renderAll();
                }
                , 'fabric', function(o, obj, error) {}
                );
            }
            toJSON() {
                return JSON.stringify(this.items);
            }
        }
        class DetailsPanel {
            constructor(sitePlanner) {
                var self = this;
                this.selected = null;
                this.$panel = $('.details-panel', sitePlanner.$element);
                $('input, select', this.$panel).on('change', function(e) {
                    if (!self.selected) return;

                    if ($(this).attr('type') == 'checkbox') {
                        self.selected.set($(this).data('key'), $(this).prop('checked'));
                    } else {
                        self.selected.set($(this).data('key'), $(this).val());
                    }
                    sitePlanner.canvas.renderAll();
                });
                sitePlanner.canvas.on('object:selected', function (e) {
                    self.onSelect(e.target);
                });
                sitePlanner.canvas.on('selection:cleared', function (e) {
                    self.onDeselect();
                });
                $('button', this.$panel).on('click', function() {
                    if (!self.selected) return;
                    var funcName = $(this).data('func');
                    self.selected[funcName].call(self.selected)
                });
            }
            onSelect(obj) {
                this.selected = obj;
//                $('div[data-type="global"]').hide();
                $('div[data-usage="subDetail"]').hide();
                var $typeBox = $('div[data-type="'+obj.type+'"]', this.$panel);
                $typeBox.show();
                $typeBox.find('input, select').each(function() {
                    var key = $(this).data('key');
                    if (!key) return;
                    var value = obj.get(key);
                    if ($(this).attr('type') == 'checkbox')
                        $(this).prop("checked", value);
                    else
                        $(this).val(value);
                });
            }
            onDeselect() {
//                $('div[data-type="global"]').show();
                $('div[data-usage="subDetail"]').hide();

                this.selected = null;
            }
        }
        /**
         * Main class, holds everything together
         */
        class SitePlanner {
            constructor(element) {
                var self = this,
                    $canvas = $('.site-planner-canvas', element);
                this.$element = $(element);
                this.$uiDefault = $("#default-ui");
                this.$uiImageExport = $("#image-export-ui");
                this.$zoom = $('.crop[data-key="zoom"]', this.$uiImageExport);
                this.$width = $('.crop[data-key="width"]', this.$uiImageExport);
                this.$height = $('.crop[data-key="height"]', this.$uiImageExport);
                this.isDragging = false;
                this.itemPool = JSON.parse($canvas.html());
                this.isBusy = false;
                /** @type ItemList **/
                this.itemList = new ItemList(this);
                /** @type Progress **/
                this.progressBar = null;
                this.mapImages = [];
                this.cropperOverlay = null;
                this.planList = [];
                this.plan = {
                    id: 0,
                    name: 'Unbennant',
                    longitude: 48.249338,
                    latitude: 11.562462,
                    zoom: 7,
                    scale: 1,
                    mapType: 'satellite',
                    diameter: 2,
                    data: {}
                };
                this.cropedImageBlob = null;
                //init
                $canvas.html('');
                this.canvas = new fabric.MyCanvas($canvas[0], {
                    width: 900,
                    height: 600,
                    backgroundColor : "#c2c2c2",
                });
                fabric.Object.prototype.set({
                    transparentCorners: false,
                    borderColor: '#ff00ff',
                    cornerColor: '#ff0000',
                });
                this.canvas.dirty = true;
                this.initControls();
                this.updateProgressBar(0);
                this.details = new DetailsPanel(this);
                //preload all necessary images
                for(var i = 0; i < this.itemPool.length; i++) {
                    if (this.itemPool[i].image != null) {//dess muss man hier machen aber
                        preloadUrls.push(this.itemPool[i].image);
                    }
                }
                preloadImages(preloadUrls, function(images) {
                    self.updateProgressBar(1);
                    preloadedImages = images;
                    console.log('images loaded', preloadedImages);
                    console.log('images loaded', preloadUrls);
                }, function(progress) {
                    self.updateProgressBar(progress);
                });
                //alternate image background ----------------------------------
//                var src = '/img/html.bg.png';
//                this.canvas.backgroundColor = new fabric.Pattern({
//                    source: src,
//                    repeat: 'repeat',
//                    backgroundImageOpacity: 0.5,
//                    backgroundImageStretch: false,
//                });
            }
            initControls() {
                var self = this;
                this.loadSitePlanList();
                this.updateMapConfig();
                this.canvas.on('zoom', this.updateCropConfig.bind(this));
                //belongs to #default-ui
                $('button.load-plan', this.$element).click(function (e) {
                    if (self.isBusy) return;
                    var planID = $('.plan-select', this.$element).val();
                    (new PNotify({
                        title: lang.askSure,
                        text: lang.warnSaveData,
                        icon: 'glyphicon glyphicon-question-sign',
                        hide: false,
                        confirm: {
                            confirm: true
                        },
                        buttons: {
                            closer: false,
                            sticker: false
                        },
                        history: {
                            history: false
                        },
                        addclass: 'stack-modal',
                        stack: {'dir1': 'down', 'dir2': 'right', 'modal': true}
                    })).get().on('pnotify.confirm', function(){
                        self.loadSitePlan(planID);
                    }).on('pnotify.cancel', function(){
                        self.isBusy = false;
                    });
                });
                $('button.save-plan', this.$element).click(function (e) {
                    if (self.isBusy) return;
                    self.savePlan();
                });
                $('button.new-plan', this.$element).click(function (e) {
                    if (self.isBusy) return;
                    self.isBusy = true;
                    (new PNotify({
                        title: lang.askSure,
                        text: lang.warnSaveData,
                        icon: 'glyphicon glyphicon-question-sign',
                        hide: false,
                        confirm: {
                            confirm: true
                        },
                        buttons: {
                            closer: false,
                            sticker: false
                        },
                        history: {
                            history: false
                        },
                        addclass: 'stack-modal',
                        stack: {'dir1': 'down', 'dir2': 'right', 'modal': true}
                    })).get().on('pnotify.confirm', function(){
                        self.plan.id = 0;
                        self.itemList.clear();
                        self.readMapConfig();
                        self.isBusy = false;
                        self.setMap();
                    }).on('pnotify.cancel', function(){
                        self.isBusy = false;
                    });
                });
                $('button.setMap', this.$element).click(function () {
                    self.readMapConfig();
                    self.setMap();
                });

                $('button.addText', this.$element).click(function (e) {
                    var obj = new fabric.Textbox('Text', {
                        top: 0,
                        left: 0,
                        fontSize: 25,
                        fontFamily: 'Arial',
                        textAlign: 'left',
                        width: 100,
                        backgroundColor: '#FFFFA5'
                        , shadow: new fabric.Shadow( { color: 'rgba(0,0,0,0.8)', offsetX: 5, offsetY: 5 })
                    });
                    self.itemList.add(obj);
                    self.canvas.centerObject(obj);

                    self.canvas.setActiveObject(obj);
                });
                $('.itemList li', this.$element).click(function(e) {
                    var id = $(this).data('id');
                    var templateItem;
                    for(var i = 0; i < self.itemPool.length; i++) {
                        if (self.itemPool[i].id == id) {
                            templateItem = self.itemPool[i];
                            break;
                        }
                    }
                    /** @type fabric.Object */
                    var obj = self.itemList.create(templateItem);
                    self.canvas.centerObject(obj);
                    self.canvas.setActiveObject(obj);
                });
                $('button.createImage', this.$element).click(function (e) {
                    if (self.isBusy) return;
                    self.startCropper();
                });

                //belongs to #image-export-ui
                $('.image-export button.abort', this.$element).on('click', function (e) {
                    e.stopPropagation();
                    self.stopCropper();
                });
                $('.image-export button.crop', this.$element).on('click', function (e) {
                    self.doCrop();
                    //show save box
                    $('.save-box', self.$uiImageExport).show();
                });
                $('.image-export button.save-image', this.$element).on('click', function (e) {
                    var name = $('#image-name', self.$uiImageExport).val();
                    if (!name || name == '') {
                        self.showError(lang.needPlanName);
                        return;
                    }
                    if (!self.cropedImageBlob) {
                        self.showError('no croped image to save!', lang.ohno);
                    }
                    http.postBlob("/siteplanner/imageUpload", self.cropedImageBlob, name + '.png')
                        .progress(function(value) {
                            console.log(value);
                        })
                        .done(function(e) {
                            if(e.error)
                                if (e.code == 5)
                                    self.showError(lang.imageNameTaken, lang.ohno);
                                else
                                    self.showError(e.msg, lang.ohno);
                            else
                                self.showInfo(e.msg, lang.successSave);
                        });
                });
                $('input.crop', this.$element).on('change', function (e) {
                    var key = $(this).data('key');
                    console.log(key)
                });
                //global key events
                $(document).keyup(function(e) {
                    if(e.key === "Delete") {
                        self.itemList.removeSelected();
                    }
                });
            }
            updateProgressBar(value) {
                if (typeof value === 'number') {
                    if (value === 0) {
                        this.progressBar = notify.startProgress('siteplanner');
                    }
                    this.progressBar.set(value);
                } else if (value === false) {
                    //hide progress element
                    this.progressBar.stop();
                }
            }
            //error handling
            showError(msg, title) {
                var opt = {};
                opt.text = msg;
                opt.type = 'error';
                opt.addclass = "stack-topleft";
                if (title) opt.title = title;
                new PNotify(opt);
            }
            showInfo(msg, title) {
                var opt = {};
                opt.text = msg;
                opt.type = 'info';
                opt.addclass = "stack-topleft";
                if (title) opt.title = title;
                new PNotify(opt);
            }
            //read/write config from/to html inputs
            readMapConfig() {
                this.plan.name          = $('#plan-name').val();
                this.plan.longitude     = parseFloat($('#lon').val());
                this.plan.latitude      = parseFloat($('#lat').val());
                this.plan.zoom          = parseInt($('#zoom').val());
                this.plan.scale         = parseInt($('#scale-select').val());
                this.plan.mapType       = $('#maptype-select').val();
                this.plan.diameter      = parseInt($('#diameter').val());
            }
            updateMapConfig() {
                $('#plan-name')     .val(this.plan.name);
                $('#lon')           .val(this.plan.longitude);
                $('#lat')           .val(this.plan.latitude);
                $('#zoom')          .val(this.plan.zoom);
                $('#scale-select')  .val(this.plan.scale);
                $('#maptype-select').val(this.plan.mapType);
                $('#diameter')      .val(this.plan.diameter);
            }
            updateCropConfig() {
                this.$zoom.val(this.canvas.getZoom());
                if (this.cropperOverlay) {
                    this.cropperOverlay.setCoords();
                    var rect = this.cropperOverlay.getBoundingRect();
                    this.$width.val(rect.width);
                    this.$height.val(rect.height);
                }
            }
            //load and set the map images
            setMap(progress) {
                if (this.isBusy && !progress) return;
                var self = this;
                this.isBusy = true;
                (progress)? progress(0): this.updateProgressBar(0);

                //remove old map images
                for (var i = 0; i < this.mapImages.length; i++) {
                    this.canvas.remove(this.mapImages[i]);
                }
                this.mapImages = [];

                this.canvas.setViewPort(0, 0);
                this.canvas.setZoom(0.4);
                this.canvas.renderAll();

                this.itemList.hide();
                this.itemList.update();

                var urls = createGoogleMapStaticImageUrls(this.plan);
                var createUrlProcess = 0;
                function finish() {
                    self.canvas.deactivateAll().renderAll();
                    self.itemList.show();
                    (progress)? progress(1): self.updateProgressBar(1);
                    //@todo set viewport position to center of map
                    self.canvas.renderAll();
                    self.isBusy = false;
                }
                function createFromImage(img, line, pos, zIndex) {
                    var img = new fabric.Image(img, {
                        scaleX: 0.2,
                        scaleY: 0.2
                    });
                    img.set('isMap', true);
                    img.scale(1 / self.plan.scale).set({
                        left: pos * 640,
                        top: line * 610,
                        scale: 2,
                        selectable: false,
                        originX: 'left',
                        originY: 'top',
                        transparentCorners: false
                    });
                    self.canvas.add(img);
                    img.moveTo(zIndex);
                    self.mapImages.push(img);
                    createUrlProcess++;
                    if (createUrlProcess >= self.plan.diameter) {
                        finish();
                    }
                }
                preloadImagesAsDataURL(urls, function(images) {
                    for (var line = 0; line < self.plan.diameter; line++) {
                        for (var pos = 0; pos < self.plan.diameter; pos++) {
                            createFromImage(images[line * self.plan.diameter + pos], line, pos, line + 1);
                        }
                    }
                }, function(value) {
                    (progress)? progress(value): self.updateProgressBar(value);
                }, function() {
                    //show error bla pls try again
                    window.notify.error("Please try again.", "Error while loading map");
                    self.itemList.show();
                    self.canvas.renderAll();
                    self.progressBar.stop();
                    self.isBusy = false;
                });
            }
            //plan management (list/get/save) and html select field update
            updatePlanList() {
                $('.plan-select', this.$element).empty();
                for(var i = 0; i < this.planList.length; i++) {
                    $('.plan-select', this.$element).append('<option value="' + this.planList[i].id + '">' + this.planList[i].name + '</option>');
                }
            }
            loadSitePlanList(callback) {
                $.getJSON("/siteplanner/list", function(result){
                    //save and update plan list
                    this.planList = result.data;
                    this.updatePlanList();
                    callback && callback();
                }.bind(this));
            }
            loadSitePlan(planID) {
                if (this.isBusy) return;
                this.isBusy = true;
                var self = this;
                this.updateProgressBar(0);
                this.itemList.clear();
                $.getJSON("/siteplanner/get/" + planID , function(result){
                    self.updateProgressBar(0.2);
                    var data = result.data;
                    //search in planList for id and replace -> if not found, push it
                    var found = false;
                    for(var i = 0; i < self.planList; i++) {
                        if (self.planList[i].id == planID) {
                            found = true;
                            //replace data
                            self.planList[i] = data;
                            break;
                        }
                    }
                    if (!found) {
                        self.planList.push(data);
                    }
                    self.plan = data;

                    self.updateMapConfig();
                    self.readMapConfig();
                    self.itemList.fromString(self.plan.data);

                    self.setMap(function(value) {
                        self.updateProgressBar(0.2 + (value * 0.8));
                    });
                });
            }
            savePlan() {
                if (this.isBusy) return false;
                var name = $('#plan-name', this.$element).val();
                if (!name || name === "") {
                    //@todo add error class to input --- red boarder or so
                    new PNotify({
                        title: lang.ohno,
                        text: lang.needPlanName,
                        type: 'error',
                        addclass: "stack-topleft",
                    });
                    return;
                }
                this.isBusy = true;
                this.updateProgressBar(0);
                var self = this;
                this.plan.name = name;
                this.plan.data = this.itemList.toJSON();

                http.postJson('/siteplanner/save', this.plan, function () {
                    self.loadSitePlanList(function() {
                        notify.success(lang.successSave);
                    });
                }, function (value) {
                    self.updateProgressBar(value);
                });
                return true;
            }
            stopCropper() {
                self.cropedImageBlob = null;
                this.$uiImageExport.addClass('hidden');
                this.$uiDefault.removeClass('hidden');
                $('.save-box', this.$uiImageExport).hide();
                $('.preview', this.$uiImageExport).empty();
                if (!this.cropperOverlay) return;
                this.cropperOverlay.remove();
                this.canvas.remove(this.cropperOverlay);
                this.cropperOverlay = null;
                this.itemList.set('selectable', true);
            }
            doCrop() {
                if (!this.cropperOverlay) return;
                var self = this,
                    storedZoom = this.canvas.getZoom();

//                window.notify.startProgress('Crop');
                this.canvas.setZoom(this.$zoom.val());
                this.cropperOverlay.setCoords();
                var viewMat = this.canvas.viewportTransform.slice();
                var finalValues = fabric.util.qrDecompose(viewMat);
                var bounds = this.cropperOverlay.getBoundingRect(true, true);

                this.canvas.toBlob({
                    format: 'png',
                    left: bounds.left * viewMat[0] + finalValues.translateX,
                    top: bounds.top * viewMat[3] + finalValues.translateY,
                    width: bounds.width * viewMat[0],
                    height: bounds.height * viewMat[3]
                }, function(blob) {
                    self.cropedImageBlob = blob;
                    self.canvas.setZoom(storedZoom);
                    var urlCreator = window.URL || window.webkitURL;
                    var imageUrl = urlCreator.createObjectURL(blob);

                    var img = new Image;
                    img.onload = function(){};
                    img.src = imageUrl;
                    $('.preview', self.$uiImageExport).empty();
                    $('.preview', self.$uiImageExport).append(img);
                });

//                window.notify.startProgress('Crop');
            }
            startCropper() {
                if (this.isBusy) return;
                this.$uiImageExport.removeClass('hidden');
                this.$uiDefault.addClass('hidden');
                if (this.cropperOverlay != null) {
                    this.stopCropper();
                }
                this.cropperOverlay = new fabric.CropBox({
                    width: 100,
                    height: 100,
                    fill: 'rgba(0,0,0,0)',
                });
                this.itemList.set('selectable', false);
                this.canvas.deactivateAll();
                this.canvas.add(this.cropperOverlay);
                this.canvas.centerObject(this.cropperOverlay);
                this.canvas.setActiveObject(this.cropperOverlay);
                this.cropperOverlay.on('scaling', this.updateCropConfig.bind(this));
                this.updateCropConfig();
            }
        }
        $.fn.SitePlanner = function(options) {
            new SitePlanner(this);
        };
    }(jQuery));

    $(document).ready(function() {
        $('#sitePlanner').SitePlanner();
    });
</script>